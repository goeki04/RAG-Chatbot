env AZURE_CLIENT_SECRET;

worker_processes auto;

events {
    worker_connections 1024;
}

http {
    lua_package_path "/usr/local/openresty/luajit/lib/lua/5.1/?.lua;/usr/local/openresty/lualib/?.lua;;";
    lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
    lua_ssl_verify_depth 3;
    resolver 127.0.0.11 8.8.8.8 1.1.1.1 valid=300s ipv6=off;
    
    lua_shared_dict discovery 1m;
    lua_shared_dict jwks 1m;
    lua_shared_dict sessions 10m;

    init_by_lua_block {
        _G.get_oidc_opts = function()
            local env_secret = os.getenv("AZURE_CLIENT_SECRET") or "session-fallback-secret-12345"
            return {
                discovery = "https://login.microsoftonline.com/0ae51e19-07c8-4e4b-bb6d-648ee58410f4/v2.0/.well-known/openid-configuration",
                client_id = "78d6118c-85ef-4009-8873-1fce155bc843",
                client_secret = env_secret,
                session_secret = env_secret,
                scope = "openid profile email",
                ssl_verify = "yes",
                redirect_uri = "http://localhost:8080/callback",
                discovery_cache_dict = "discovery",
                jwks_cache_dict = "jwks",
                cache_segment = "sessions",
                session_contents = {
                    id_token=true, 
                    access_token=true,
                    user=true
                },
                renew_session_on_expiry = true,
                force_reauthorize = false,
                lifecycle = {
                    id_token_expiration_leeway = 60,
                    max_session_idle = 86400,
                    max_session_age = 172800,
                    refresh_session_interval = 900
                }
            }
        end
    }

    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    upstream qdrant_cluster {
        server vdb_1:6333 max_fails=3 fail_timeout=10s;
        server vdb_2:6333 max_fails=3 fail_timeout=10s;
        keepalive 64;
    }

    server {
        listen 80;

        location /callback {
            access_by_lua_block {
                local res, err = require("resty.openidc").authenticate(_G.get_oidc_opts())
                if err then
                    ngx.log(ngx.ERR, "Auth Error: " .. err)
                    return ngx.exit(401)
                end
            }
        }

        location ~ ^/(chat/)?_stcore/ {
            proxy_pass http://chatbot:8501;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $host;
            
            proxy_buffering off;
            proxy_read_timeout 86400;
        }

        location /chat/ {
            access_by_lua_block {
                local res, err = require("resty.openidc").authenticate(_G.get_oidc_opts())
                if not res then return ngx.exit(401) end

                local roles = res.id_token.roles or {}
                if type(roles) == "string" then roles = { roles } end
                
                local has_access = false
                for _, role in pairs(roles) do
                    if role == "admin" or role == "project_a.rw" or role == "project_a.reader" then
                        has_access = true
                        break
                    end
                end

                if not has_access then
                    ngx.status = 403
                    ngx.say("Forbidden: Kein Zugriff auf den Chat.")
                    return ngx.exit(403)
                end
            }

            proxy_pass http://chatbot:8501;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            proxy_buffering off;
            proxy_read_timeout 86400;
        }

        location / {
            set $backend_qdrant "qdrant_cluster";
            
            access_by_lua_block {
                local res, err = require("resty.openidc").authenticate(_G.get_oidc_opts())
                if not res then return ngx.exit(401) end

                local roles = res.id_token.roles or {}
                if type(roles) == "string" then roles = { roles } end

                local is_admin = false
                local is_rw = false
                local is_reader = false

                for _, role in pairs(roles) do
                    if role == "admin" then is_admin = true
                    elseif role == "project_a.rw" then is_rw = true
                    elseif role == "project_a.reader" then is_reader = true end
                end

                if not (is_admin or is_rw or is_reader) then
                    ngx.status = 403
                    ngx.say("Forbidden: Keine gultige Rolle.")
                    return ngx.exit(403)
                end

                local method = ngx.req.get_method()
                if (method ~= "GET" and method ~= "HEAD") and (is_reader and not (is_admin or is_rw)) then
                    ngx.status = 403
                    ngx.say("Forbidden: Nur Lesezugriff erlaubt.")
                    return ngx.exit(403)
                end

                if method == "DELETE" and not is_admin then
                    ngx.status = 403
                    ngx.say("Forbidden: Nur Admins duerfen loeschen.")
                    return ngx.exit(403)
                end
            }

            proxy_pass http://$backend_qdrant;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}