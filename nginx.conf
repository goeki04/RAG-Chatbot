
env AZURE_CLIENT_SECRET;

worker_processes auto;

events {
    worker_connections 1024;
}

http {
    lua_package_path "/usr/local/openresty/luajit/lib/lua/5.1/?.lua;/usr/local/openresty/lualib/?.lua;;";
    
    lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
    lua_ssl_verify_depth 3;

    proxy_buffer_size 128k;
    proxy_buffers 4 256k;
    proxy_busy_buffers_size 256k;
    large_client_header_buffers 4 16k;

    resolver 127.0.0.11 8.8.8.8 1.1.1.1 valid=30s ipv6=off;
    
    lua_shared_dict discovery 1m;
    lua_shared_dict jwks 1m;

    upstream qdrant_cluster {
        server vdb_1:6333 max_fails=3 fail_timeout=10s;
        server vdb_2:6333 max_fails=3 fail_timeout=10s;
        keepalive 64;
    }

    server {
        listen 80;
        set $azure_client_id "78d6118c-85ef-4009-8873-1fce155bc843";
        set $azure_discovery "https://login.microsoftonline.com/0ae51e19-07c8-4e4b-bb6d-648ee58410f4/v2.0/.well-known/openid-configuration";
        --redirect
        location /callback {
            access_by_lua_block {
                local openidc = require("resty.openidc")
                local env_secret = os.getenv("AZURE_CLIENT_SECRET") or "session-fallback-secret-12345"

                local opts = {
                    discovery = ngx.var.azure_discovery,
                    client_id = ngx.var.azure_client_id,
                    client_secret = "1ax8Q~wrEobXF5LEI4iBh~MeYU3S9k50VtmEGb-c",
                    session_secret = env_secret,
                    scope = "openid profile email",
                    ssl_verify = "yes",
                    redirect_uri = "http://localhost:8080/callback",
                    discovery_cache_dict = "discovery",
                    jwks_cache_dict = "jwks"
                }
                
                local res, err = openidc.authenticate(opts)
                if err then
                    ngx.log(ngx.ERR, "Callback Auth Error: " .. err)
                    return ngx.exit(401)
                end
            }
        }

        location / {
            access_by_lua_block {
                local openidc = require("resty.openidc")
                local env_secret = os.getenv("AZURE_CLIENT_SECRET") or "session-fallback-secret-12345"

                local opts = {
                    discovery = ngx.var.azure_discovery,
                    client_id = ngx.var.azure_client_id,
                    client_secret = "1ax8Q~wrEobXF5LEI4iBh~MeYU3S9k50VtmEGb-c",
                    session_secret = env_secret,
                    ssl_verify = "yes",
                    scope = "openid profile email",
                    redirect_uri = "http://localhost:8080/callback"
                }
                --get the token
                local res, err = openidc.authenticate(opts)
                
                if err then
                    ngx.status = 401
                    ngx.say("Auth failed: " .. err)
                    return ngx.exit(401)
                end
                local token = res.id_token
                local rolesOriginal = token.roles or {}
                
                if type(rolesOriginal) == "string" then
                    rolesOriginal = { rolesOriginal }
                end
                --iterate through all roles the token provides and check roles
                local has_access = false
                for _, role in pairs(rolesOriginal) do
                    if role == "project_a.reader" or role == "project_a.rw" or role == "admin" then
                        has_access = true
                        break
                    end
                end

                if not has_access then
                    ngx.status = 403
                    ngx.header.content_type = "application/json"
                    ngx.say(require("cjson").encode({
                        error = "Forbidden",
                        message = "Keine gultige Rolle gefunden",
                        deine_rollen = rolesOriginal
                    }))
                    return ngx.exit(403)
                end

            }

            proxy_pass http://qdrant_cluster;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}